[[bitcoin-architecture]]
== 1.0 Bitcoin Architecture

=== Executables

To be able to interact with Bitcoin network, the user needs to connect to a Bitcoin node, a software whose main purposes are:

* Download the blockchain.
* Enforce the rules of the network.
* Validate and relay the transactions.

Running your own node is of utmost importance when spending or transferring the bitcoins. The other option is trusting other nodes which is a major security hole. When doing it, the user is not only leaking personal data, but also trusting in the data and in the rules defined by others, who can be malicious agents or harmful to the network or even harmful to the user.

The other component necessary to store and move coins is a wallet. The primary function of the wallet is to manage the private keys and sign transactions.

Bitcoin protocol does not have the concept of accounts, like banks. Wallets manage a pool of unfathomable random numbers called private keys, which should be kept secret by the user. Bitcoin addresses are derived from these private keys and they can be used to receive coins (and move them later). Only one receiving address must be used for each transaction.

Signing a transaction means the user is moving the money and has authorized the transaction. To create the signature, the wallet will use the private key associated to the coin(s) the user wants to spend.

Node and wallet are completely different things, although they can eventually come together in the same software. Node is related to bitcoin network and protocol while a wallet is related to the oneâ€™s private keys and transactions. It is very important to know the difference between these two concepts to be able to have a better understanding of Bitcoin architecture.

Bitcoin Core has been the reference implementation since its first version. It is not just a single software. Bitcoin Core is a solution that includes a node, a graphical interface, and a command line interface. There are also wallet features (including a sophisticated coin selection) but since version v0.21, wallets are no longer created by default. The reason for this is to make the use of multiple wallets more intuitive.

To start a node, just run the main app bitcoind implemented in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/bitcoind.cpp[src/bitcoind.cpp]`. This executable is expected to run as a daemon (in the background). It also provides a REST interface, so anyone authorized can access and work with the node.

After running the daemon, the user will be able to interact with the node through a command-line application called bitcoin-cli that is implemented in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/bitcoin-cli.cpp[src/bitcoin-cli.cpp]`. It implements some RPC commands that are sent via REST to the node (the bitcoind daemon) and displays the results.

Another simpler and friendlier option to start the node and operate it is starting bitcoin-qt, implemented in `src/qt/main.cpp`. This is an intuitive graphical interface, where all interactions take place via buttons. The user can create multiple wallets and check other information about the node such as the peer connection and network statistics. 

.Bitcoin Core Executables
image::images/chapter_1_0/executables.svg[]
[CChainParams, align="center"]

{empty} +

=== Protocol - P2P

Bitcoin is a peer-to-peer protocol. There is no central server that can determine the rules. So, to be able to communicate with other peers and exchange information, the nodes need to establish a common protocol, so they can understand each other.

The file `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h[src/protocol.h]` defines all types of messages (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/protocol.h#L62[namespace NetMsgType]`) that will be used in this communication. As can be seen in the code below, each message has a comment with a succinct description of its purpose.

[source,c++]  
----
/**
 * Bitcoin protocol message types. When adding new message types, don't forget
 * to update allNetMessageTypes in protocol.cpp.
 */
namespace NetMsgType {

/**
 * The version message provides information about the transmitting node to the
 * receiving node at the beginning of a connection.
 */
extern const char* VERSION;
/**
 * The verack message acknowledges a previously-received version message,
 * informing the connecting node that it can begin to send other messages.
 */
extern const char* VERACK;
// ...
/**
 * The inv message (inventory message) transmits one or more inventories of
 * objects known to the transmitting peer.
 */
extern const char* INV;
/**
 * The getdata message requests one or more data objects from another node.
 */
extern const char* GETDATA;
// ...
}
----

But how does the node find the other peers to exchange messages ? When running for the first time, the node connects to a bunch of servers denominated DNS Seeds which provide a list of IP addresses that have recently been running a Bitcoin client. After connecting to those IP addresses, the node starts to exchange messages with the peers. +
DNS seeds are  hardcoded and stored in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/chainparams.cpp[src/chainparams.cpp]`.

[source,c++]  
----
vSeeds.emplace_back("seed.bitcoin.sipa.be"); // Pieter Wuille, only supports x1, x5, x9, and xd
vSeeds.emplace_back("dnsseed.bluematt.me"); // Matt Corallo, only supports x9
vSeeds.emplace_back("dnsseed.bitcoin.dashjr.org"); // Luke Dashjr
vSeeds.emplace_back("seed.bitcoinstats.com"); // Christian Decker, supports x1 - xf
vSeeds.emplace_back("seed.bitcoin.jonasschnelli.ch"); // Jonas Schnelli, only supports x1, x5, x9, and xd
----

New peers can also be manually added with the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L442[-addnode=<addr>]`. The connection parameters, like `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L78[DEFAULT_MAX_PEER_CONNECTIONS]` or `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L64[MAX_ADDNODE_CONNECTIONS]`, can be found in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h[net.h]` file.

== Concurrency model

Bitcoin Core does a lot of things at the same time. It downloads the blockchain, processes new transactions, validates new blocks, responds to the user events and to network events and so on. 

Therefore, a multithreaded application seems appropriate for this case. Threads allow multiple functions to be executed concurrently, improving considerably the application's responsiveness. Multithreading also allows the use of multiprocessors efficiently, enabling parallelism to perform intensive tasks.

An example of a task in the Bitcoin Core that can use multiple threads is the verification of scripts in a block. Since there are many transactions in a block, parallelizing the execution greatly improves performance.

Most threads are started (directly or indirectly) in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1263[init.cpp:AppInitMain(...)]`. This is the Bitcoin node's main function. If the node is started through the `bitcoind` daemon, this function will be called inside the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/bitcoind.cpp#L40[src/bitcoind.cpp:AppInit(...)]`. If it is started through the `bitcoin-qt` graphic interface, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/interfaces/node.cpp#L61[src/interfaces/node.cpp:appInitMain(...)]` will call the function.

Another relevant function is  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.cpp#L2448[CConnman::Start(...)]` since network-related threads are instantiated and excuted in it.

[source,c++]  
----
bool AppInitMain(...)
{
    // ...
    if (!node.connman->Start(*node.scheduler, connOptions)) {
        return false;
    }
    // ...
}
----

The table below shows the threads that will be presented next.
// ---
[%autowidth]
|===
|Purpose | # threads | Task run

|<<script-verification>>
|nproc or 16
|`ThreadScriptCheck()`

|<<loading-blocks>>
|1
|`ThreadImport()`

|<<servicing-rpc-calls>>
|4 or more
|`ThreadHTTP()`

|<<load-peer-adresses-from-dns-seeds>>
|1
|`ThreadDNSAddressSeed()`

|<<send-and-receive-messages-to-and-from-peers>>
|1
|`ThreadSocketHandler()`

|<<initializing-network-connections>>
|1
|`ThreadOpenConnections()`


|<<opening-added-network-connections>>
|1
|`ThreadOpenAddedConnections()`

|<<process-messages-from-net-net-processing>>
|1
|`ThreadMessageHandler()`

|===


=== TraceThread

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L432[TraceThread]` is a wrapper for a function that just calls it once. It also names the thread and handles `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h#L441[boost::thread_interrupted]` exception. In Bitcoin Core code, it is usually used as _fn_ argument to thread constructor `std::thread (Fn&& fn, Args&&... args)`. It is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.h[src/util/system.h]`.

[source,c++]  
----
template <typename Callable> void TraceThread(const char* name,  Callable func)
{
    util::ThreadRename(name);
    try
    {
        LogPrintf("%s thread start\n", name);
        func();
        LogPrintf("%s thread exit\n", name);
    }
    catch (const boost::thread_interrupted&)
    {
        LogPrintf("%s thread interrupt\n", name);
        throw;
    }
    catch (const std::exception& e) {
        PrintExceptionContinue(&e, name);
        throw;
    }
    catch (...) {
        PrintExceptionContinue(nullptr, name);
        throw;
    }
}
----

[[script-verification]]
=== Script Verification

The function that perform the script verification is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/script/interpreter.cpp#L1937[bool src/script/interpreter.cpp:VerifyScript(...)]`. It is called in at least three points of the application:

* When the node receives a new transaction, which is handled by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void src/net_processing.cpp:PeerManager::ProcessMessage(...)]` when the received message is a _tx_ type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2940[if (msg_type == NetMsgType::TX)]`).

* When the node wants to broadcast a new transaction. It is done by `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L29[TransactionError src/node/transaction.cpp:BroadcastTransaction(...)]`.

* When receiving a new block, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2274[void net_src/processing.cpp:PeerManager::ProcessMessage(...)]` will identify a _getblocks_ message type (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2754[if (msg_type == NetMsgType::GETBLOCKS)]`) and https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2779[will call] `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2744[bool src/validation.cpp:CChainState::ActivateBestChain(...)]`.

In the fist two case, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1062[static bool validation.cpp:AcceptToMemoryPool(...)]` function is called to handle the new transaction, as can be seen in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L3006[ProcessMessage(...)]` and `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/node/transaction.cpp#L66[BroadcastTransaction(...)]`. It will try to add the transaction to mempool. In the last case, the function that will handle the new block is `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool src/validation.cpp:CChainState::ConnectBlock(...)]`. Both of them end up calling `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[src/validation.cpp:bool CheckInputScripts(...)]`.

`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` validates the scripts of all the inputs of the `const CTransaction& tx` transaction passed as parameter. However, the relevant parameter in this context is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L201[std::vector<CScriptCheck> *pvChecks = nullptr]`. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` is a closure representing one script verification and it stores references to the spending transaction.

[source,c++]  
----
class CScriptCheck
{
    private:
        CTxOut m_tx_out;
        const CTransaction *ptxTo;
        unsigned int nIn;
        unsigned int nFlags;
        bool cacheStore;
        ScriptError error;
        PrecomputedTransactionData *txdata;
    // ...
}
----

The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L252[CScriptCheck]` method that matters is the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1464[bool src/validation.cpp:CScriptCheck::operator()()]`. It overloads the operator `()` and perform the script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1467[VerifyScript(...)]`).

[source,c++]  
----
bool CScriptCheck::operator()() {
    const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;
    const CScriptWitness *witness = &ptxTo->vin[nIn].scriptWitness;
    return VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *txdata), &error);
}
----

So if the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1561[std::vector<CScriptCheck> *pvChecks]` is not null, the  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` will add each script validation (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1560[CScriptCheck check]`) to the vector, so they can be executed in parallel. Otherwise, the script is verified immediately.

[source,c++]  
----
bool CheckInputScripts(const CTransaction& tx, ..., std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
{
    // ...
    for (unsigned int i = 0; i < tx.vin.size(); i++) {
        CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);
        if (pvChecks) {
            pvChecks->push_back(CScriptCheck());
            check.swap(pvChecks->back());
        } else if (!check()) {
            // ...
        }
        // ...
    }
    // ...
}
----

The only function that makes use of script validation parallelization is the aforementioned `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[bool CChainState::ConnectBlock(...)]` due to the quantity of transactions in a block. If the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[g_parallel_script_checks]` is true, the script verification vector that has been filled in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1516[CheckInputScripts(...)]` is allocated in  `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2134[CCheckQueueControl<CScriptCheck> control(...)]`. The `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2218[control.Wait()]` initiates the their execution and wait for the end. +
`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L135[g_parallel_script_checks]` is a global parameter and it will be better detailed soon.

[source,c++]  
----
bool CChainState::ConnectBlock(const CBlock& block, ...)
{
    // ...
    CCheckQueueControl<CScriptCheck> control(fScriptChecks && g_parallel_script_checks ? &scriptcheckqueue : nullptr);
    // ...

    for (unsigned int i = 0; i < block.vtx.size(); i++)
    {
        if (!tx.IsCoinBase())
        {
            std::vector<CScriptCheck> vChecks;
            if (!CheckInputScripts(tx,..., g_parallel_script_checks ? &vChecks : nullptr)) { /*...*/ }
            control.Add(vChecks);  
        }
    }

    if (!control.Wait()) {
        LogPrintf("ERROR: %s: CheckQueue failed\n", __func__);
        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, "block-validation-failed");
    }
}
----

The code that will be excute the work (in this case, it is the script verification) can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/checkqueue.h#L66[bool src/checkqueue.h:CCheckQueue::Loop(...)]`.

[source,c++]  
----
template <typename T>
class CCheckQueue
{
private:
    /** Internal function that does bulk of the verification work. */
    bool Loop(bool fMaster = false)
    {
        // ...
        do {
            // ...
            // execute work
            for (T& check : vChecks)
                if (fOk)
                    fOk = check();
            vChecks.clear();
        } while (true);
}
----

The number of script-checking threads is defined in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1263[init.cpp:AppInitMain(...)]`. The user can set the number of the threads using the argument `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]`. If the number is negative, it will limit the threads. +
If the user does not pass the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L418[-par]` parameter, `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[src/util/system.cpp:GetNumCores()]` is called to get the number of concurrent threads supported by the implementation. Then 1 is subtracted from this number because the the main thread is already being  used. `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/util/system.cpp#L1277[GetNumCores()]` is just a wrapper for C++ standard function `std::thread::hardware_concurrency()`. +
There is also a maximum number of dedicated script-checking threads allowed, that is 15 (`https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.h#L70[MAX_SCRIPTCHECK_THREADS]`).
Note that `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1333[g_parallel_script_checks]` is set to true, allowing parallelization in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1946[ConnectBlock(...)]` function.

[source,c++]  
----
bool AppInitMain(...)
{
    //...
    int script_threads = args.GetArg("-par", DEFAULT_SCRIPTCHECK_THREADS);
    if (script_threads <= 0) {
        // -par=0 means autodetect (number of cores - 1 script threads)
        // -par=-n means "leave n cores free" (number of cores - n - 1 script threads)
        script_threads += GetNumCores();
    }

    // Subtract 1 because the main thread counts towards the par threads
    script_threads = std::max(script_threads - 1, 0);

    // Number of script-checking threads <= MAX_SCRIPTCHECK_THREADS
    script_threads = std::min(script_threads, MAX_SCRIPTCHECK_THREADS);

    LogPrintf("Script verification uses %d additional threads\n", script_threads);
    if (script_threads >= 1) {
        g_parallel_script_checks = true;
        for (int i = 0; i < script_threads; ++i) {
            threadGroup.create_thread([i]() { return ThreadScriptCheck(i); });
        }
    }
    //...
}
----

And finally the command `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1335[ThreadScriptCheck(i)]` simply initiates a new worker thread one or several times, according to the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1318[script_threads]` value. Its implementation can be found in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L1823[src/validation.cpp]`.

[source,c++]  
----
static CCheckQueue<CScriptCheck> scriptcheckqueue(128);

void ThreadScriptCheck(int worker_num) {
    util::ThreadRename(strprintf("scriptch.%i", worker_num));
    scriptcheckqueue.Thread();
}
----

Therefore, these are the main steps in verifying the script. However, there is already a change after version v0.21, making it more efficient and https://github.com/bitcoin/bitcoin/pull/18710/files#diff-35390fbd9f90018a4bf7d663283bb8b812cc52c4e277e115eb9426c79df439a9L13[reducing the dependency] on `<boost/thread>`. It can be verified in the  https://github.com/bitcoin/bitcoin/pull/18710[PR #18710]. There is also an interesting https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/test/checkqueue_tests.cpp[CCheckQueue unit tests], implemented in the https://github.com/bitcoin/bitcoin/pull/9497/files[PR #9497].

[[loading-blocks]]
=== Loading Blocks

One of the first thing the node need to do is load the blocks and decides which chain to work.

The thread `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1880[g_load_block]` invoke the function `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L694[void ThreadImport(...)]` to load the blocks on startup. If the user is rebuilding the blockchain index (`-reindex`) or is loading blocks directly from files (`-loadblock`), it will be handled in this thread. After loading the blocks, it tries to find the best chain in `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/validation.cpp#L2870[CChainState::ActivateBestChain(...)]`.

It happens in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/init.cpp#L1263[init.cpp:AppInitMain(...)]`.

[source,c++]  
----
std::vector<fs::path> vImportFiles;
for (const std::string& strFile : args.GetArgs("-loadblock")) {
    vImportFiles.push_back(strFile);
}

g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {
    ThreadImport(chainman, vImportFiles, args);
});
----

[[servicing-rpc-calls]]
=== Servicing RPC Calls

To allow user to interact with the node, an HTTP server should be enabled to process the requests. In order to do it, the `init.cpp:AppInitServers(...)` calls `httpserver.cpp:InitHTTPServer()` that, as the name implies, initializes the server and `httpserver.cpp:StartHTTPServer()` that constructs new thread objects.

`g_thread_http` is event dispatcher thread, that manages the http event loop. It is interrupted when  InterruptHTTPServer() is called.

`g_thread_http_workers` distributes the work over multiple threads and handles longer requests off the event loop thread. `HTTPWorkQueueRun` is a simple wrapper to set thread name and run work queue. The number of the threads to service RPC calls is defined by the configuration argument `-rpcthreads` or `httpserver.h:DEFAULT_HTTP_THREADS=4`, whichever is greater.

[source,c++]  
----
static std::thread g_thread_http;
static std::vector<std::thread> g_thread_http_workers;

void StartHTTPServer()
{
    LogPrint(BCLog::HTTP, "Starting HTTP server\n");
    int rpcThreads = std::max((long)gArgs.GetArg("-rpcthreads", DEFAULT_HTTP_THREADS), 1L);
    LogPrintf("HTTP: starting %d worker threads\n", rpcThreads);
    g_thread_http = std::thread(ThreadHTTP, eventBase);

    for (int i = 0; i < rpcThreads; i++) {
        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue, i);
    }
}
----

[[load-peer-adresses-from-dns-seeds]]
=== Load Peer Adresses From DNS Seeds

As said before, the node initially queries the hardcoded DNS Seeds to find new peers to connect to.

`net.h:std::thread threadDNSAddressSeed` is a thread created with `CConnman::ThreadDNSAddressSeed(...)` wrapped into `TraceThread(...)`. It will run once when node starts.

It is called in `init.cpp:AppInitMain(...)` function when the command `node.connman->Start(*node.scheduler, connOptions)` is executed.

Note if a particular list is provided in the configuration parameters (`-dnsseed`), this thread will not be instantiated.

[source,c++]  
----
if (!gArgs.GetBoolArg("-dnsseed", true))
    LogPrintf("DNS seeding disabled\n");
else
    threadDNSAddressSeed = std::thread(&TraceThread<std::function<void()> >, "dnsseed", std::function<void()>(std::bind(&CConnman::ThreadDNSAddressSeed, this)));
----

[[send-and-receive-messages-to-and-from-peers]]
=== Send And Receive Messages To And From Peers

`std::thread threadSocketHandler` is created using `CConnman::ThreadSocketHandler()` method wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    threadSocketHandler = std::thread(&TraceThread<std::function<void()> >, "net", std::function<void()>(std::bind(&CConnman::ThreadSocketHandler, this)));
}
----

It seems strange at first, because `TraceThread(...)` ensures unique execution and the node will send and receive messages several time while connected, not just one time.

But a close look into the `CConnman::ThreadSocketHandler()` code shows it has  a loop that keeps running until be eventually interrupted by the `interruptNet` flag.

[source,c++]  
----
void CConnman::ThreadSocketHandler()
{
    while (!interruptNet)
    {
        DisconnectNodes();
        NotifyNumConnectionsChanged();
        SocketHandler();
    }
}
----

This flag is set `false` only in the `CConnman::Interrupt()` that interrupts all the connections.

`CConnman::DisconnectNodes()` disconnect any connected nodes if the `fNetworkActive` is false. It can be disabled/enabled by `setnetworkactive` RPC command. The function also disconnects unused nodes and delete disconnected nodes.

`NotifyNumConnectionsChanged()` updates the nubmer of connections and ,if the client interface is enabled, it notifies when the number of connections change.

`SocketHandler()` handles socket connections, incoming messages (`pnode->vRecvMsg`) and the messages to send (`pnode->cs_vSend`);

[[initializing-network-connections]]
=== Initializing Network Connections

The thread `std::thread threadOpenConnections` opens and manages connections to other peers. Before instantiating this thread, it is checked if the application is started with `-connect=0` or `-connect=<ip>`. +
If `-connect` is set to 0, this `threadOpenConnections` thread will not be created. +
If an specific IP is set, there will be only one active outbound connection and with that IP. +
If the `-connect` parameter is not passed, all the outbound network connections will be initiate.

[source,c++]  
----
if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty())
        threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, "opencon", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this, connOptions.m_specified_outgoing)));
----

The total number of outbound connection `m_max_outbound` is defined in `src/net.h`. It usually will be 11, the sum of the full relay (8), block relay (2) only and feeler (1) connections.

[source,c++]  
----
/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */
static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;
/** Maximum number of addnode outgoing nodes */
static const int MAX_ADDNODE_CONNECTIONS = 8;
/** Maximum number of block-relay-only outgoing connections */
static const int MAX_BLOCK_RELAY_ONLY_CONNECTIONS = 2;
/** Maximum number of feeler connections */
static const int MAX_FEELER_CONNECTIONS = 1;

void Init(...) {
    m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;
}
----

The use of `-connect=0` to disable automatic outbound connections has been implemented in https://bitcoin.org/en/release/v0.14.0#p2p-protocol-and-network-code[v0.14], with the the https://github.com/bitcoin/bitcoin/pull/9002[PR #9002].

[[opening-added-network-connections]]
=== Opening Added Network Connections

`std::thread threadMessageHandler` is created using `CConnman::ThreadOpenAddedConnections` wrapped into `TraceThread(...)`.

`CConnman::ThreadOpenAddedConnections()` calls `CConnman::GetAddedNodeInfo()` to retrieve the nodes that has been` added manually and try to open connection with them calling `OpenNetworkConnection(...)`.

[source,c++]  
----
// Initiate manual connections
threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, "addcon", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));
----

[[process-messages-from-net-net-processing]]
=== Process Messages from `net` -> `net_processing`

When the node starts, `init.cpp:AppInitMain(...)` calls `node.connman->Start(*node.scheduler, connOptions)`.

`std::thread threadMessageHandler` is created using `CConnman::ThreadMessageHandler` wrapped into `TraceThread(...)`.

[source,c++]  
----
bool CConnman::Start(...)
{
    // Process messages
    threadMessageHandler = std::thread(&TraceThread<std::function<void()> >, "msghand", std::function<void()>(std::bind(&CConnman::ThreadMessageHandler, this)));
}
----

As already seen in <<send-and-receive-messages-to-and-from-peers>>, this code will not be executed once. `TraceThread(...)` ensures unique execution but the `CConnman::ThreadMessageHandler()` has a loop that keeps running until be eventually interrupted by the `flagInterruptMsgProc` flag.

This flag is set `true` only in the `CConnman::Interrupt()` that interrupts all connections.

[source,c++]  
----
void CConnman::ThreadMessageHandler()
{
    while (!flagInterruptMsgProc)
    {
        // ...

        for (CNode* pnode : vNodesCopy)
        {
            if (pnode->fDisconnect)
                continue;

            // Receive messages
            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);
            // ...
            // Send messages
            {
                LOCK(pnode->cs_sendProcessing);
                m_msgproc->SendMessages(pnode);
            }
            // ...
        }

        // ...
    }
}
----

[[notification-mechanism]]
=== Notifications Mechanism (`ValidationInterface`)

A lot of event happen at same time in Bitcoin Core: new messages arrive all the time, are processed and sometime, announcements need to be made. For example, if a wallet is connected to Bitcoin Core and a transaction related to this wallet arrives, the wallet needs to be notified; when a new block arrives, the chain and the wallet need to be updated; transaction can also be removed from mempool and it needs to be notified and so on.

In a good software architecture, the components that trigger notifications and those that listen to them are completely decoupled. The message producer sends the notification to the listeners, but it does not know (and does not care) how the message will be processed by the recipient. The sender's main concern should be to ensure that the message is delivered and to do this asynchronously, so as not to block any execution.

A known pattern for asynchronous message service is called _message queue_. When a relevant event is triggered, a message will be are stored on the queue until they are processed by the consumer and deleted. The class that implement this kind of service in Bitcoin Core is the `CScheduler` and the method that keeps the queue running is `void CScheduler::serviceQueue()`. The queue service is started as soon as the application is initiated on `AppInitMain(...)`. This service will be more detailed later.

[source,c++]  
----
bool AppInitMain(...)
{
    // Start the lightweight task scheduler thread
    threadGroup.create_thread([&] { TraceThread("scheduler", [&] { node.scheduler->serviceQueue(); }); });
}
----

In Bitcoin Core, there are two main classes that implements the notification between the components, the `CValidationInterface`, that works as notification receivers (also known as _subscribers_ ) and the `CMainSignals`, that works as unique notification sender (also known as _publisher_). When some event needs to be published, the message is sent by `static CMainSignals g_signals` to all the subscribers.

// Not ZMQ

`CValidationInterface` is the interface that any class interested in listening to the events should implement. The events are: `UpdatedBlockTip`, `TransactionAddedToMempool`, `TransactionRemovedFromMempool`, `BlockConnected`, `BlockDisconnected, `ChainStateFlushed`, `BlockChecked` and `NewPoWValidBlock`. 

[source,c++]  
----
class CValidationInterface {
protected:
    ~CValidationInterface() = default;
    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}

    virtual void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}

    virtual void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}
    
    virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) {}
    
    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) {}
    
    virtual void ChainStateFlushed(const CBlockLocator &locator) {}
    
    virtual void BlockChecked(const CBlock&, const BlockValidationState&) {}
    
    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};
    friend class CMainSignals;
};
----

All of these methods represent the events and although they are defined as `virtual`, they have an empty default implementation `{}`. So the subclasses only needs to implement the methods / events that matter.

The classes that implement them are `src/net_processing.h:PeerManager`, `src/index/base.h:BaseIndex`, `src/interfaces/chain.cpp:NotificationsProxy`, `src/rpc/mining.cpp:submitblock_StateCatcher` and `src/zmq/zmqnotificationinterface:CZMQNotificationInterface`.

The code below shows `PeerManager` implementing `CValidationInterface`. Note that the class does not implement the `TransactionAddedToMempool`, `TransactionRemovedFromMempool`,  `ChainStateFlushed`, what means it have no interest in these events.

[source,c++]  
----
class PeerManager final : public CValidationInterface, public NetEventsInterface {
    /**
     * Overridden from CValidationInterface.
     */
    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;
    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;
    /**
     * Overridden from CValidationInterface.
     */
    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;
    /**
     * Overridden from CValidationInterface.
     */
    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;
    /**
     * Overridden from CValidationInterface.
     */
    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;
    // ..
}
----

But it is not enough to just implement those methods. To be able to listen to these events, it is necessary to register them as subscribers of `CMainSignals`, which is the unique publisher, so they can receive the notifications. It is done registering the `CValidationInterface` object through the `RegisterSharedValidationInterface(...)` or `RegisterValidationInterface(...)` functions.

`PeerManager`, `BaseIndex`, `CZMQNotificationInterface` use `RegisterValidationInterface(...)` while `NotificationsProxy`, `submitblock_StateCatcher` use `RegisterSharedValidationInterface(...)`. The codes below illustrate this.

[source,c++]  
----
bool AppInitMain(...)
{
    // ...
    node.peerman.reset(new PeerManager(chainparams, *node.connman, node.banman.get(), *node.scheduler, chainman, *node.mempool));
    RegisterValidationInterface(node.peerman.get());
    // ...
#if ENABLE_ZMQ
    g_zmq_notification_interface = CZMQNotificationInterface::Create();

    if (g_zmq_notification_interface) {
        RegisterValidationInterface(g_zmq_notification_interface);
    }
#endif
    //...
}
----
[source,c++]  
----
static RPCHelpMan submitblock()
{
    // ...
    auto sc = std::make_shared<submitblock_StateCatcher>(block.GetHash());
    RegisterSharedValidationInterface(sc);
    bool accepted = EnsureChainman(request.context).ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);
    UnregisterSharedValidationInterface(sc);
    // ...
}
----

Calling any of the two methods has the same effect. `RegisterValidationInterface(...)` receives raw pointer as parameter, then convert it to a shared pointer with empty block control and send it to the `RegisterSharedValidationInterface(...)`. Note that the NotificationsProxy` and `submitblock_StateCatcher` classes, that call directly `RegisterSharedValidationInterface(...)`  use `std::make_shared` to wrap the argument in a `std::shared_ptr`. The others call `RegisterValidationInterface(...)`. +
Using shared pointers instead of raw pointers ensures the pointer is only deleted when the last reference is deleted. More details can be found in the https://github.com/bitcoin/bitcoin/pull/18338[PR #18338].

[source,c++]  
----
void RegisterSharedValidationInterface(std::shared_ptr<CValidationInterface> callbacks)
{
    // Each connection captures the shared_ptr to ensure that each callback is
    // executed before the subscriber is destroyed. For more details see #18338.
    g_signals.m_internals->Register(std::move(callbacks));
}

void RegisterValidationInterface(CValidationInterface* callbacks)
{
    // Create a shared_ptr with a no-op deleter - CValidationInterface lifecycle
    // is managed by the caller.
    RegisterSharedValidationInterface({callbacks, [](CValidationInterface*){}});
}
----

To register a new subscriber, `RegisterSharedValidationInterface(...)` calls `g_signals.m_internals->Register(...)`. +
`g_signals` is a static `CMainSignals` that, as said before, is the unique publisher and `m_internals` is `MainSignalsInstance` struct.

This struct has two important properties: `std::list<ListEntry> m_list` and `SingleThreadedSchedulerClient m_schedulerClient`. The first one is the list that stores the references for all the subscribers (objects that implement `CValidationInterface` interface) and the second one queues the messages to be sent and executes them serially.

[source,c++]  
----
struct MainSignalsInstance {
private:
    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };
    std::list<ListEntry> m_list GUARDED_BY(m_mutex);
    // ...
public:
    SingleThreadedSchedulerClient m_schedulerClient;

    void Register(std::shared_ptr<CValidationInterface> callbacks)
    {
        // Register a new CValidationInterface subscriber
    }

    // ...
}
----

`CMainSignals` is the class that broadcast the notifications to all the subscribers. Note the some methods of this class have the same name of the `CValidationInterface` class. This way, it is easy to identify which event is being triggered, since both the publisher and the subscriber use the same name for the methods. Note that `CMainSignals` _does not_ implement `CValidationInterface`, the methods having the same name is just a design decision.

[source,c++]  
----
class CMainSignals {
private:
    std::unique_ptr<MainSignalsInstance> m_internals;

    // ...

public:
    
    // ...

    void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);
    void TransactionAddedToMempool(const CTransactionRef&, uint64_t mempool_sequence);
    void TransactionRemovedFromMempool(const CTransactionRef&, MemPoolRemovalReason, uint64_t mempool_sequence);
    void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex);
    void BlockDisconnected(const std::shared_ptr<const CBlock> &, const CBlockIndex* pindex);
    void ChainStateFlushed(const CBlockLocator &);
    void BlockChecked(const CBlock&, const BlockValidationState&);
    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);
};
----

To notify each of the subscribers, the `MainSignalsInstance m_internals` iterates each `CValidationInterface` element (which is also called `callback`) and constructs a lambda with the params that the message have (in case of `TransactionAddedToMempool`, they are the `tx` and `mempool_sequence`). The lambda body is the execution of `CValidationInterface::TransactionAddedToMempool(...)`. Instead of running the lambda immediately, it is allocated in the `SingleThreadedSchedulerClient m_schedulerClient` to be executed serially.

[source,c++]  
----
#define ENQUEUE_AND_LOG_EVENT(event, fmt, name, ...)           \
    do {                                                       \
        auto local_name = (name);                              \
        LOG_EVENT("Enqueuing " fmt, local_name, __VA_ARGS__);  \
        m_internals->m_schedulerClient.AddToProcessQueue([=] { \
            LOG_EVENT(fmt, local_name, __VA_ARGS__);           \
            event();                                           \
        });                                                    \
    } while (0)
// ...
void CMainSignals::TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {
    auto event = [tx, mempool_sequence, this] {
        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempool(tx, mempool_sequence); });
    };
    ENQUEUE_AND_LOG_EVENT(event, "%s: txid=%s wtxid=%s", __func__,
                          tx->GetHash().ToString(),
                          tx->GetWitnessHash().ToString());
}
----

And finally, to trigger an event, it is only needed to call `GetMainSignals().[event_name]`. The `MemPoolAccept::AcceptSingleTransaction` function below illustrates it, sending the notification that a new transaction is added to mempool, passing as parameters the transaction and the mempool sequence.

[source,c++]  
----
bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)
{
    // ...

    GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());

    return true;
}
----

The diagram below shows the notifications classes (and some of their fields) presented so far.

.Notification Class Diagram
image::images/chapter_1_0/notification_classes.svg[]
[CChainParams, align="center"]

=== Regions

// table

|===
|Files | Layer| Description

|<<nethcpp>>
|Network
|It handles node communication with the P2P network

|<<net_processinghcpp>>
|Network Processing
|It adapts the incoming network messages to Validation layer

|<<validationhcpp>>
|Validation
|It handles modifying in-memory data structures for chainstate and transactions

|===

[[nethcpp]]
=== `net.{h,cpp}`

// std::unique_ptr<CAddrMan> addrman;
// std::unique_ptr<CConnman> connman;
// std::unique_ptr<PeerManager> peerman;
// std::unique_ptr<BanMan> banman;
// std::unique_ptr<CScheduler> scheduler;

The `src/net.{h,cpp}` files implement the most basic network level. It is the "bottom" of the Bitcoin Core stack. It handles node communication with the P2P network.

// node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), *node.addrman, args.GetBoolArg("-networkactive", true));
// nSeed0 & nSeed1In - id

The network connection is enabled when `!node.connman->Start(*node.scheduler, connOptions)` is called in the application main function `src.cpp:AppInitMain(...)`. The `node` variable refers to the `struct NodeContext`. It is a struct containing references to chain state and connection state. This is used by the init function, RPC, GUI and test code to pass object references around
without needing to declare the same variables and parameters repeatedly, or to use globals. The struct is defined in `src/node/context.h`.

Before this struct was created, the global variable `g_conman` was used to manage the connection. But using global variables reduces the modularity and flexibility of the program, so the https://github.com/bitcoin/bitcoin/pull/16839[PR #16839] has got rid of the some global variables and has made `g_conman` a NodeContext member (now it is called `connman`).

[source,c++]  
----
struct NodeContext {
    std::unique_ptr<CAddrMan> addrman;
    std::unique_ptr<CConnman> connman;
    std::unique_ptr<CTxMemPool> mempool;
    std::unique_ptr<CBlockPolicyEstimator> fee_estimator;
    std::unique_ptr<PeerManager> peerman;
    // ...
}
----

The `connOptions` parameter is a `CConnman::Options` object. It stores many of configurable network parameters the user can define when starting the node. If no parameters are defined, the default values are in `net.h`.

[source,c++]  
----
// src/init.cpp
bool AppInitMain(...)
{
    // ...
    CConnman::Options connOptions;
    connOptions.nLocalServices = nLocalServices;
    connOptions.nMaxConnections = nMaxConnections;
    connOptions.m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, connOptions.nMaxConnections);
    connOptions.m_max_outbound_block_relay = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);
    connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;
    connOptions.nMaxFeeler = MAX_FEELER_CONNECTIONS;
    // ...
}
----

The `scheduler` parameter is a `CScheduler` object. In this function, it is used to schedule how often the peer IP addresses will be stored on the disk. In this case, it is 15 minutes, as defined in the `DUMP_PEERS_INTERVAL` variable.  The file that stores information about the peers is called `peers.dat`.

The function `bool CConnman::Start(...)` loads the addresses from peers.dat and stores them in `CAddrMan& addrman` variable. `CAddrMan` has a table with information about all stored peers, the `std::map<int, CAddrInfo> mapInfo`, and oanther field with the peers ID and their network addresses, the `std::map<CNetAddr, int> mapAddr`.

Then, the file `anchors.dat` is deserialized. This file contains addresses that were saved during the previous clean shutdown. 
The node will attempt to make block-relay-only connections to them.
These addresses are stored in `std::vector<CAddress> m_anchors`.

The reason there are two files is a risk mitigation measure implemented in the https://github.com/bitcoin/bitcoin/pull/15759[PR #15759] and the https://github.com/bitcoin/bitcoin/pull/17428[PR #17428]. The first change was motivated by the https://arxiv.org/pdf/1812.00942.pdf[TxProbe] paper, which  describes that transaction relay leaks information that adversaries can use to infer the network topology. The second one was motivated by the https://eprint.iacr.org/2015/263.pdf[Eclipse Attack] paper, that presents an attack that allows an adversary controlling a sufficient number of IP addresses to monopolize all connections to and from a victim bitcoin node.

The connection to the peers from `anchors.dat` is called block-relay-only and to the peers from `peers.dat` is called outbound-full-relay. The first type only relays blocks/block headers and the second one, includes all messages type.

[source,c++]  
----
bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)
{
    // ...
    // Load addresses from peers.dat
    int64_t nStart = GetTimeMillis();
    {
        CAddrDB adb;
        if (adb.Read(addrman))
            LogPrintf("Loaded %i addresses from peers.dat  %dms\n", addrman.size(), GetTimeMillis() - nStart);
        else {
            addrman.Clear(); // Addrman can be in an inconsistent state after failure, reset it
            LogPrintf("Recreating peers.dat\n");
            DumpAddresses();
        }
    }

    if (m_use_addrman_outgoing) {
        // Load addresses from anchors.dat
        m_anchors = ReadAnchors(GetDataDir() / ANCHORS_DATABASE_FILENAME);
        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {
            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);
        }
        LogPrintf("%i block-relay-only anchors will be tried for connections.\n", m_anchors.size());
    }
    // ...
}
----

Then, the `threadSocketHandler` is started. It enable the node to accept new connections (function `CConnman::AcceptConnection(...)`), to receive and send data.

Next, the following threads are initiated sequentially:   `threadDNSAddressSeed`, `threadOpenAddedConnections`, `ThreadOpenConnections` and the `ThreadMessageHandler`.

The first one checks if the node was able to connect successfully to at least 2 peers loaded from the files. If so, it skips querying DNS and the thread execution finishes. If there is a reasonable number of peers in `CAddrMan& addrman`, it is spent some time trying them first. This improves user privacy by creating fewer identifying DNS requests, reduces trust by giving seeds less influence on the network topology, and reduces traffic to the seeds.

The `threadOpenAddedConnections` calls `GetAddedNodeInfo()` to get informations about the nodes added using the RPC "addnode" RPC command. These nodes are stored in the `CConnman` member field `std::vector<std::string> vAddedNodes`, that is protected by `cs_vAddedNodes` mutex. `ThreadOpenAddedConnections()` is a infinite loop that checks the if an added addresses is connected and tries to connect if it is not.

`ThreadOpenConnections` tries to open connections to the peers. Opening block-relay connections to addresses from anchors.dat gets the highest priority. Then opening outbound-full-relay is the priority until the node's full-relay capacity is hit.

And finally, `ThreadMessageHandler` is the thread that receives messages, process them in `src/net_processing.cpp:PeerManagerImpl::ProcessMessages(...)` and send messages to the peers.

[[net_processinghcpp]]
=== `net_processing.{h,cpp}`

The main class of this region is the `PeerManagerImpl`. It implements three interfaces: `CValidationInterface`, `NetEventsInterface` and `PeerManager`. 
The `CValidationInterface` was already discussed in <<notification-mechanism>>, `NetEventsInterface` is about handling network event triggered by the peers, like initializing or removing a peer. And `PeerManager` interface is high level interaction with the peer such as processing their messages, managing peer's misbehavior score or relaying transaction.

.Class PeerManagerImpl
image::images/chapter_1_0/PeerManagerImpl.svg[]
[PeerManagerImpl, align="center"]

{empty} +
// Add PeerManagerImpl code
Note that there are two methods with very similiar names: `bool PeerManagerImpl::ProcessMessages(...)` and `void PeerManagerImpl::ProcessMessage(...).` The first thing to observe that they are from diferent interfaces. The first method comes from the `NetEventsInterface` interface and the second one, from `PeerManager` interface.

`bool PeerManagerImpl::ProcessMessages(...)` is a lower level method that is called by the previous region. It firstly checks if there are _getdata_ requests from the peer and in that event, it calls `PeerManagerImpl::ProcessGetData(...)`. Then, it check for orphan transaction and calls `PeerManagerImpl::ProcessOrphanTx(...)` if so. If neither of these is the case, the `PeerManagerImpl::ProcessMessage(...)` function will be called.

[source,c++]  
----
bool PeerManagerImpl::ProcessMessages(...)
{
    bool fMoreWork = false;

    PeerRef peer = GetPeerRef(pfrom->GetId());
    if (peer == nullptr) return false;

    {
        LOCK(peer->m_getdata_requests_mutex);
        if (!peer->m_getdata_requests.empty()) {
            ProcessGetData(*pfrom, *peer, interruptMsgProc);
        }
    }

    {
        LOCK2(cs_main, g_cs_orphans);
        if (!peer->m_orphan_work_set.empty()) {
            ProcessOrphanTx(peer->m_orphan_work_set);
        }
    }

    try {
        ProcessMessage(*pfrom, msg_type, msg.m_recv, msg.m_time, interruptMsgProc);
        // ...
    }

    // ...
}
----

`src/net_processing.cpp:PeerManagerImpl::ProcessMessages(...)` is the main function of this region and it tis a is a giant conditional to handle the messages sent by the peers. It is a high level network function that understand the messages type and knows how to handle them, extracting the data and sending him to the next region, `validation.{h,cpp}`.

[source,c++]  
----
void PeerManagerImpl::ProcessMessage(...)
{
    // ...
    if (msg_type == NetMsgType::VERACK) {
        // ...
        return;
    }

    if (msg_type == NetMsgType::SENDHEADERS) {
        // ...
        return;
    }

    if (msg_type == NetMsgType::SENDCMPCT) {
        // ...
        return;
    }

    // ...

    if (msg_type == NetMsgType::INV) {
        // ...
        return;
    }
}
----

// There is GETDATA message type and it is also handled in ProcessMessage(...). The same applies to TX message / orphan tx.

`PeerManager` interface also provides the method `void Misbehaving(...)` to handle with potentially malicious nodes. It increments peer's misbehavior score. Whenever an possibly harmful behavior is identified, this method is called, passing as parameter the `nodeId`, how much points the node must added (`howmuch`) and the message that describes the misbehavior (`message`).

[source,c++]  
----
void PeerManagerImpl::Misbehaving(const NodeId pnode, const int howmuch, const std::string& message)
{
    // ..

    LOCK(peer->m_misbehavior_mutex);
    peer->m_misbehavior_score += howmuch;
    const std::string message_prefixed = message.empty() ? "" : (": " + message);
    if (peer->m_misbehavior_score >= DISCOURAGEMENT_THRESHOLD && peer->m_misbehavior_score - howmuch < DISCOURAGEMENT_THRESHOLD) {
        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);
        peer->m_should_discourage = true;
    } else {
        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d)%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);
    }
}
----

If the `m_misbehavior_score` attribute of the peer is equal or greater than `DISCOURAGEMENT_THRESHOLD` value (which is 100), mark the it to be discouraged, meaning the peer might be disconnected and added to the discouragement filter. The discouraged nodes are stored in `src/banman.h:BanMan::m_discouraged`.

There are two methods focused in applying penalties if there is something wrong. They are `PeerManagerImpl::MaybePunishNodeForBlock(...)` and `PeerManagerImpl::MaybePunishNodeForTx(...)`. In these methods, it can be seen that not all conflicts are necessarily invalid. 

There are some situations where the `Misbehaving(...)` is called to handle messages that are not in accordance with the Bitcoin protocol. This list is not exhaustive.

[%autowidth]
|===
|Misbehavior | # Points Added

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1075[Peer provides a block which the data does not match the data committed to by the PoW]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1092[Peer sends a block that has been cached as invalid]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1100[Peer sends a block whose previous block is invalid]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1103[Peer sends a block whose previous block the node does not have]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1124[Peer sends a transaction that does not comply with consensus rules]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1775[Peer requests an index in GETBLOCKTXN  higher than the total number of transactions in a block]
|100

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1824[Peer sends non-connecting headers]
|20

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L1832[Peer sends non-continuous headers sequence]
|20

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2583[Peer sends ADDR or ADDRv2 message whose size is greater than the allowed] (1000 addresses, as defined in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net.h#L56[src/net.h:MAX_ADDR_TO_SEND]`)
|20

|https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2661[Peer sends INV message whose number of entries is greater than the allowed] (50000 entries, as defined in the `https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L74[src/net_processing.h:MAX_INV_SZ]`) +
https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/net_processing.cpp#L2735[The same verification is done for GETDATA message]
|20

|===

[[validationhcpp]]
=== `validation.{h,cpp}`

The validation file handles verifying received data and modifying of in-memory data structures for chainstate and transaction (mempool) based on certain acceptance rules.

Although `CValidationInterface` is not directly related to `validation.cpp` files, almost all events of this interface are triggered in the validation file, except for the `TransactionRemovedFromMempool` event which is called in `txmempool.cpp`. All the events are triggered by calling the publisher `GetMainSignals()`.

When a new block arrives (`NetMsgType::BLOCK`), it will be intercepted by the ProcessMessage(), that will call `m_chainman.ProcessNewBlock(...)`. `ChainstateManager& m_chainman`  is a PeerManagerImpl variable member and the `ChainstateManager` class is declared in `validation.h`.

//Bitcoin relies on the Unspent Transaction Outputs (UTXO)set to efficiently verify new generated transactions. Every unspent out-put, no matter its type, age, value or length is stored in every full node.

// The  Unspent  Transaction  Output  (UTXO)  set  is  the  subset  of  Bitcoin  trans-action outputs that have not been spent at a given moment. 

// Bitcoin makes use of the Unspent Transaction Output (UTXO) set in order tokeep track of output transactions that have not been yet spent and thus can beused as inputs to new transactions. Bitcoin full nodes keep a copy of the UTXOset in order to validate transactions and produce new ones without having tocheck the whole blockchain.

This class was https://github.com/bitcoin/bitcoin/pull/17737/files#diff-d3c243938494b10666b44404a27af7d84b44a72b85a27431e0c89e181462ca6eR815[introduced] in the https://github.com/bitcoin/bitcoin/pull/17737[PR #17737] as part of the https://github.com/bitcoin/bitcoin/projects/11[assumeutxo project]. `Assume UTXO` is an idea similar to `assumevalid`. In `assumevalid`, there is a hash that is hard-coded into the code, the user assumes all the blocks in the chain that ends in that hash and their transactions have valid scripts. This is an optimization for startup, but the node skips script validation, implicitly trusting the developers who hard-coded the default block hash.  Bitcoin Core will still validate most parts of the block, including Proof of Work, UTXOs, amounts, etc. The only thing that is not validated are scripts because they are expensive. `assumevalid` has been introduced in the https://github.com/bitcoin/bitcoin/pull/9484[PR #9484].

The `assumeutxo` does something similiar, but for the UTXO Set. It would be a way to initialize a node using a headers chain and a serialized version of the UTXO state which was generated from another node at some block height. The basic idea is to allow nodes to initialize using a serialized version of the UTXO set rendered by another node at some predetermined height. The initializing node syncs the headers chain from the network, then obtains and loads one of these UTXO snapshots.

Based upon the snapshot, the node is able to quickly reconstruct its chainstate, and compares a hash of the resulting UTXO set to a preordained hash hard-coded in the software (exactly like `assumevalid`). 

The node then syncs to the network tip and afterwards begins a simultaneous background validation (conventional IBD) up to the base height of the snapshot in order to achieve full validation. Crucially, even while the background validation is happening the node can validate incoming blocks and transact with the benefit of the full (assumed-valid) UTXO set. Snapshots could be obtained from multiple separate peers in the same manner as block download

The project is ongoing and much of the code is still being refactored. ChainstateManager is one of the newly created classes for the project. It provides an interface for managing the one or two chainstates: an IBD chainstate generated by downloading blocks, and an optional snapshot chainstate loaded from a UTXO snapshot.

[source,c++]  
----
class ChainstateManager
{
private:
    std::unique_ptr<CChainState> m_ibd_chainstate GUARDED_BY(::cs_main);
    std::unique_ptr<CChainState> m_snapshot_chainstate GUARDED_BY(::cs_main);
    CChainState* m_active_chainstate GUARDED_BY(::cs_main) {nullptr};
    // ...
}
----

The `m_ibd_chainstate` field is the chainstate used under normal operation ("regular" IBD). If a snapshot is in use, it is used for background validation while downloading the chain. The `m_snapshot_chainstate` field is the chainstate initialized on the basis of a UTXO snapshot. If this is non-null, it is always our active chainstate. `m_active_chainstate` points to either the ibd or snapshot chainstate and indicates the most-work chain. The method below demonstrate this behavior.

[source,c++]  
----
CChainState& ChainstateManager::InitializeChainstate(CTxMemPool& mempool, const uint256& snapshot_blockhash)
{
    bool is_snapshot = !snapshot_blockhash.IsNull();
    std::unique_ptr<CChainState>& to_modify =
        is_snapshot ? m_snapshot_chainstate : m_ibd_chainstate;

    if (to_modify) {
        throw std::logic_error("should not be overwriting a chainstate");
    }
    to_modify.reset(new CChainState(mempool, m_blockman, snapshot_blockhash));

    // Snapshot chainstates and initial IBD chaintates always become active.
    if (is_snapshot || (!is_snapshot && !m_active_chainstate)) {
        LogPrintf("Switching active chainstate to %s\n", to_modify->ToString());
        m_active_chainstate = to_modify.get();
    } else {
        throw std::logic_error("unexpected chainstate activation");
    }

    return *to_modify;
}
----

The method `init.cpp:AppInitMain(...)` calls `chainman.InitializeChainstate(*Assert(node.mempool));` to initialize a new chain state. If, for some reason, it has already been created, an exception will be thrown. Note that the second parameter `snapshot_blockhash` has no value. In the current version, v0.21, it is not yet possible to start the server by passing a snapshot block hash as parameter. In the function, if the `snapshot_blockhash` is null, `m_ibd_chainstate` will be active chainstate (`m_active_chainstate`).  This code snippet makes it clear that the priority for the active chainstate is snapshot chainstate.

ChainstateManager has other methods related to `assumeutxo` such as `ActivateSnapshot(...)` and `ValidatedChainstate(...)`, but they are not being used yet, except for https://github.com/bitcoin/bitcoin/blob/v0.21.0/src/test/validation_chainstatemanager_tests.cpp[test unit]. But there are other methods related to block management like `ProcessNewBlockHeaders(...)` and `ProcessNewBlock(...)`. These functions are originally defined in `validation.h`, but the https://github.com/bitcoin/bitcoin/pull/18698[PR #18698] has made them members of ChainstateManager.

`ProcessNewBlockHeaders(...)` are called in `netprocessing.cpp` when a _cmpctblock_ message arrives or through the `PeerManagerImpl::ProcessHeadersMessage(` function when _headers_ message arrives. `ProcessNewBlock(...)` are called when _block_, _blocktxn_ or _cmpctblock_ message arrives. so that the <<net_processinghcpp>> region can make the communication with the <<validationhcpp>> region, the class `PeerManagerImpl` has an `ChainstateManager& m_chainman` variable member.

[source,c++]  
----
class PeerManagerImpl final : public PeerManager
{
    // ...
    ChainstateManager& m_chainman;
    // ...

    void PeerManagerImpl::ProcessMessage(...) {
        if (msg_type == NetMsgType::CMPCTBLOCK)
        {
            if (!m_chainman.ProcessNewBlockHeaders(...) {
                // ...
            }
            // ...
            if (fBlockReconstructed) {
                // ...
                m_chainman.ProcessNewBlock(...);
                //...
            }
        }

        if (msg_type == NetMsgType::BLOCKTXN)
        {
            // ...
            if (fBlockRead) {
                //...
                m_chainman.ProcessNewBlock(...);
                // ...
            }
        }

        if (msg_type == NetMsgType::BLOCK) {
            // ...
            m_chainman.ProcessNewBlock(...);
            // ...
        }
    }
}
----

Other important method is `ChainstateManager::ActiveChainstate()`, that is used to find out which  chainstate is active (`m_snapshot_chainstate` or `m_ibd_chainstate`) and returns a `CChainState` object.

`CChainState` stores and provides an API to update our local knowledge of the current best chain. For example, when a new block arrives, `CChainState` will perform most of the the work. `ChainstateManager::ProcessNewBlock()` will trigger the following methods sequentially: `CChainState::AcceptBlock(...)`,  `CChainState::ActivateBestChain(...)`, `CChainState::ActivateBestChainStep(...)`, `CChainState::ConnectTip(...)` and `CChainState::ConnectBlock(...)`. Note that all these methods are member of `CChainState` and they manage the entire cycle of accepting or rejecting a new block.

`CChainState::AcceptBlock(...)` calls `SaveBlockToDisk(...)` that calls `WriteBlockToDisk(...)`. This first method is used to find the file position (ex: 157 from `blk00157.dat`) and the second one to write block to history file.

[source,c++]  
----
static bool WriteBlockToDisk(....)
{
    // Open history file to append
    CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);
    //...

    // Write index header
    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());
    fileout << messageStart << nSize;

    // Write block
    //...
    fileout << block;

    return true;
}
----

The method above serializes the block to the file (`fileout << block`). The serialization process will be described in the Serizlization chapter.

But the important point is that the <<validationhcpp>> region also contains some utility functions for storing and reading data from disk. `WriteBlockToDisk(...)` is just an example. There are others like `ReadBlockFromDisk(...)`, `DumpMempool(...)`, `LoadMempool(...)` and `bool CChainState::FlushStateToDisk(...)`. The latter is particulary important.  

This method is called frequently, at any change in chain state or during via shutdown through `CChainState::ForceFlushStateToDisk()`. 